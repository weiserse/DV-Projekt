<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Projektskizze</title>
</head>
<body>
	<header>
		<img src="images/HFU-Logo.png">
		<h1>Projekt: M√ºhle</h1>
		<h2>Semester: SS 2022</h2>
		<b>Teammitglieder:</b>
		<ul>
			<li>Verena Glunz (verena.glunz@hs-furtwangen.de)</li>
			<li>Selina Peukert (selina.theresa.peukert@hs-furtwangen.de)</li>
			<li>Benjamin Zimmermann (b.zimmermann@hs-furtwangen.de)</li>
			<li>Sebastian Weiser (sebastian.weiser@hs-furtwangen.de)</li>
		</ul>
	</header>
	<main>
		<h2>1. Projekt-Beschreibung</h2>
		<p>Programmierung eines M√ºhlespiels, welches von zwei Spielern an einem einzigen Computer gespielt werden kann.
		   Die vollst√§ndige Anleitung des M√ºhlespiels wird im Handbuch beschrieben.</p>
		<h2>2. Features und Anforderungen</h2>
		
		<p>Das Spiel M√ºhle soll in den folgenden Wochen mit Java, Eclipse und GitHub entwickelt werden. Nach seiner Fertigstellung soll es von zwei Spielern an einem Computer in Java gespielt werden k√∂nnen. 
			Das Spiel kann hierbei in drei unterschiedliche Spielphasen eingeteilt werden:</p>
		<ul>
			<li>Setzphase</li>
			<li>Zugphase</li>
			<li>Springphase</li>
		</ul>
		<p>Aufgrund des Umfangs und der Komplexit√§t wird als Grundanforderung die reibungslose Funktion bis Ende der Setzphase angestrebt. Ziel der Entwicklung bleibt es jedoch ein komplett funktionsf√§higes M√ºhlespiel zu programmieren.</p>

		<p>Beim Starten des Spiels sollen die Spieler zuerst in einem ‚ÄûWillkommen‚Äú-Fenster mit einem M√ºhlespielfeld im Hintergrund begr√º√üt werden. Die Spieler k√∂nnen in diesem Fenster ihre Namen eintragen und ihre Spielfarbe zuordnen. Ein Spieler bekommt die schwarzen Steine, der andere Spieler die wei√üen Steine. Die Zuordnung erm√∂glicht es, w√§hrend dem Spielverlauf aktuelle Spielst√§nde anzugeben. Schlie√ülich kann das Spiel durch Klicken eines ‚ÄûStart‚Äú Buttons gestartet werden.</p>
		<img src="images/Startbild.png">
		<p>Nun √∂ffnet sich ein Fenster in der Mitte des Bildschirms, welches nicht weiter skalierbar sein soll. Auf diesem sitzen sich die beiden Spieler ‚Äûgegen√ºber‚Äú. Im Fenster wird mittig das M√ºhlebrettspielfeld von oben blickend als Bild angezeigt. Links werden Angaben zum Spieler 1 gemacht, rechts zum Spieler 2. Ein Spiel kann jederzeit durch einen Button "Neues Spiel" abgebrochen und neu gestartet werden. Die Angaben beinhalten die Information √ºber 
		<ul>
			<li>die Anzahl der Steine, die noch gesetzt werden k√∂nnen</li>
			<li>die Anzahl der Steine, die man insgesamt noch besitzt</li>
			<li>die Anzahl der Steine, die man dem anderen Spieler abgenommen hat</li>
		</ul>
		√úber dem Spielfeld wird angezeigt, welcher Spieler sich gerade an der Reihe befindet. In diesem Feld werden zu gegebener Zeit auch Anweisungen oder Warnungen ausgegeben. Die Spieler bekommen so dauerhaft einen √úberblick √ºber den Spielverlauf und die aktuelle Situation. Die 24 Felder des M√ºhlespiels sind mit Buttons hinterlegt und in einem Array gespeichert. Sie k√∂nnen jeweils den Zustand ‚Äûfrei‚Äú, ‚Äûwei√ü‚Äú oder ‚Äûschwarz annehmen‚Äú. Die gesamte Grafik der Benutzeroberfl√§che wird in 2D dargestellt. Nach jedem Spielzug wird das Spielfeld gepr√ºft und die folgende Aktion darauf angepasst. </p>
		<p>In der Setzphase platzieren die Spieler abwechselnd ihre Steine auf dem M√ºhlespielfeld. 
		Durch Anklicken eines Feldes wird der Stein auf das Feld gesetzt, es nimmt somit den Zustand "wei√ü" oder "schwarz" an. Die Steine werden hierbei mit schwarzen bzw. wei√üen Kreisen angezeigt. Setzt ein Spieler einen Stein, kann dieser Spielzug nicht mehr r√ºckg√§ngig gemacht werden und automatisch ist der andere Spieler an der Reihe. Beim Anklicken eines besetzten Feldes wird im Infofeld eine Warnung ausgegeben, dass dieser Spielzug nicht erlaubt ist. Eine doppelte Besetzung eines Feldes ist nicht m√∂glich. Sobald drei Steine einer Farbe in einer Reihe sind, wird angezeigt, dass nun ein Spielstein der anderen Farbe durch Anklicken vom Feld genommen werden kann. Dieser darf sich nicht in einer bestehenden M√ºhle befinden. Auch in diesem Fall wird ein entsprechender Hinweis im Infofeld angezeigt. </p>	
		<p>Sobald alle Steine gesetzt sind, kommt man in die zweite Phase des Spiels, der Zugphase. Zuerst klickt der Spieler auf den Stein, den er verschieben m√∂chte und anschlie√üend auf das Zielfeld. Sollte dieses besetzt sein oder sich nicht in direktem Anschluss zum ausgew√§hlten Stein befinden, wird im Infofeld wieder eine entsprechende Warnung ausgegeben. Bei einer M√ºhle darf wieder ein Stein der anderen Farbe vom Spielfeld genommen werden.</p>
		<p>Zur letzten Phase des Spiels, der Springphase, gelangen die Spieler, sobald einer von ihnen nur noch drei Spielsteine auf dem Feld hat. Auch der Beginn dieser neuen Phase wird im Infofeld angezeigt. Spieler mit nur noch drei Steinen k√∂nnen nun zu einem beliebigen Feld springen. Die Einschr√§nkung nur unmittelbar anliegende Felder anspielen zu k√∂nnen wird damit aufgehoben.</p>
		<img src="images/Hauptbild.png">
		
		<p>Sobald einem Spieler nur noch 2 Steine zur Verf√ºgung stehen, √∂ffnet sich ein neues ‚ÄûSieger‚Äú- Fenster. In diesem wird der Gewinner mit seinem Namen angezeigt und begl√ºckw√ºnscht. 
		Ein zus√§tzliches Feature ist das √ñffnen einer Gewinnstatistik. In dieser werden die Namen aller Spieler und die Anzahl ihrer gewonnenen Spiele tabellarisch aufgelistet. Voraussetzung hierf√ºr ist die dauerhafte Speicherung der Namen mit den entsprechenden Spielausg√§ngen. Durch einen Button "Zur√ºck zum Start" kann ein neues Spiel begonnen werden. 
		Ein Spiel kann jederzeit durch das Anklicken durch das ‚ÄûSchlie√üen‚Äú-Fenster beendet werden. Der Zwischenstand des Spiels wird hierbei nicht gespeichert. Generell k√∂nnen Spielz√ºge nicht r√ºckg√§ngig gemacht werden. Die bekannten M√ºhle-Spielregeln sollen im gesamten Spielverlauf eingehalten werden. Sie werden im Handbuch weiter beschrieben.
		</p>
		<img src="images/Endbild.png">
		<img src="images/Statistik.png">
	
		<h2>3. Architektur</h2>
		<p>Beschreibung der Software-Architektur</p>
		<p>	Die Klasse Spielbrett steht in einer Verbindung zur Klasse Spieler,
			welche mit den Methoden setzeStein() und nehmeStein() auf das Attribut Positionsarray zugreift.
			Auch die Klasse Stein greift mit der Methode move() auf dieses Attribut zu.
			Desweiteren steht die Klasse Stein in einer Komposition mit "Spieler". Da "Spieler" mit der Methode setzeStein()
			die Klasse "Stein" erst initialisiert kann "Stein" ohne "Spieler" nicht existieren.
			Jeder Spieler im normalen Spielverlauf 2 bis 9 Steine haben, aber in der Setzphase startet man mit 0 Steinen.
			Hingegen kann jeder Stein nur einem Spieler zugeh√∂rig sein. F√ºr "Spielbrett" gilt, dass es 2 Spieler haben muss,
			und jeder Spieler nur ein Spielfeld haben kann.</p>
			Das Klassendiagramm kann mit Hilfe von Pseudo Code (siehe HTML Quelltext) erstellt werden <a href="https://mermaid-js.github.io/mermaid/#/classDiagram">(Hilfe)</a>.

		<div class="diagram">
			classDiagram
			class Spielbrett {
				-int [] Positionsarray
				-initialisieren()
				-neuesSpiel()
				+checkMuehle()
				-drawBoard()
			}
			class Spieler {
				-int 1oder2
				-string name
				-bool amZug
				-int numZuSetzen
				-int numVerbleibend
				-setzeStein()
				-nehmeStein()
			}
			class Stein {
				-string farbe
				-bool inMuehle
				-bool neueMuehle
				-int position
				-move()
			}
			class Frames {
				-int [] size
				-bool visibility
			}
			class WelcomeScreen {
				-JLabel LabelTop
				-JtextField Textfeld1
				-JtextField Textfeld2
				-JButton StartButton
			}
			class GameScreen {
				-JButton MenuButton
				-JButton NewGameButton
				-JButton ExitButton
				-JLabel LableTurn
				-JLabel LabelPl1
				-JLabel LabelPl2
				-JPanel PanelBoard
			}
			class EndOfGameScreen {
				-JLabel LabelMatch
				-JLabel LabelWinner
				-JPanel PanelFoto
				-JButton ButtonNext
			}
				
			
			Spielbrett "2" <-- "1" Spieler
			Spieler "1" *-- "0..9" Stein
			Stein --> Spielbrett
			Frames <|-- WelcomeScreen
			Frames <|-- GameScreen
			Frames <|-- EndOfGameScreen
			GameScreen --> Spielbrett
		
		</div>
		<h2>4. Aufwandssch√§tzung und Aufteilung</h2>
		<p>TODO: Sch√§tzen Sie den Aufwand der verschiedenen Teile Ihres Programms ab und legen Sie fest, wie die Aufteilung auf die Gruppenmitglieder aussehen soll.</p>
		Die angef¸hrten Zeitangaben sind grobe Richtwerte, welche in Summer allerdings eine plausible Gesamtarbeitszeit ergeben. 
		Zudem spiegeln sie wieder, wie viel Zeit f¸r welche Arbeitsabschnitte aufgebracht werden sollte. Hˆchste Priorit‰t haben, wie oben schon angedeutet, die Mindestanforderungen, welche die meisten Arbeitsstunden auf sich vereinen.
		Die Aufgaben sind so verteilt, dass es zu einer gerechten Arbeitsteilung kommt und kein Gruppenmitglied in eine unnˆtige Leerlaufphase kommt.  
		  
		  Aufgaben im Wochen¸berblick:		Woche 1-4:			Projektskizze
		  									Woche 5-9:			Mindestanforderungen			20h
		  									Woche 9/10-11:		Zusatzaufgaben und Test			8-12h
		  									Woche 12-13:		Benutzerhandbuch und Puffer		8h
		  							
		  Konkrete Aufgabeneinteilung:		WelcomeScreen:		Sebastian						je ca. 8h
		  									GameScreen:			Verena und Benjamin 			
		  									EndofGameScreen:	Selina							
		  									
		  									Spielbrett:			Sebastian(?)					je ca. 12h
		  									Spieler:			Verena und Benjamin(?)				
		  									Stein:				Selina(?)						
		  									
		  									Zusatzaufgaben:		Alle							8h-10h
		  									
		  									Test:				Selina und Sebastian			bis 4h
		  									Benutzerhandbuch:	Verena und Benjamin 			bis 4h
		  									
		  								
		  
		<h2>Optional: Verweis auf andere HTML Dateien</h2>
		<p><a href="otherfile.html">Eine weitere HTML-Datei</a></p>
	</main>
	<footer></footer>
</body>
</html>

<!-- scripts to render diagrams (do not touch!) -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
	mermaid.initialize({startOnLoad:true});
	let diagrams = document.querySelectorAll(".diagram")
	mermaid.init({}, diagrams);
</script>
