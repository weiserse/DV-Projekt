<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Projektskizze</title>
</head>
<body>
	<header>
		<img src="images/HFU-Logo.png">
		<h1>Projekt: Mühle</h1>
		<h2>Semester: SS 2022</h2>
		<b>Teammitglieder:</b>
		<ul>
			<li>Verena Glunz (verena.glunz@hs-furtwangen.de)</li>
			<li>Selina Peukert (selina.theresa.peukert@hs-furtwangen.de)</li>
			<li>Benjamin Zimmermann (b.zimmermann@hs-furtwangen.de)</li>
			<li>Sebastian Weiser (sebastian.weiser@hs-furtwangen.de)</li>
		</ul>
	</header>
	<main>
		<h2>1. Projekt-Beschreibung</h2>
		<p>Programmierung eines Mühlespiels, welches von zwei Spielern an einem einzigen Computer gespielt werden kann.
		   Die vollständige Anleitung des Mühlespiels wird im Handbuch beschrieben.</p>
		<h2>2. Features und Anforderungen</h2>
		
		<p>Das Spiel Mühle soll in den folgenden Wochen mit Java, Eclipse und GitHub entwickelt werden. Nach seiner Fertigstellung soll es von zwei Spielern an einem Computer in Java gespielt werden können. 
			Das Spiel kann hierbei in drei unterschiedliche Spielphasen eingeteilt werden:</p>
		<ul>
			<li>Setzphase</li>
			<li>Zugphase</li>
			<li>Springphase</li>
		</ul>
		<p>Aufgrund des Umfangs und der Komplexität wird als Grundanforderung die reibungslose Funktion bis Ende der Setzphase angestrebt. Ziel der Entwicklung bleibt es jedoch ein komplett funktionsfähiges Mühlespiel zu programmieren.</p>

		<p>Beim Starten des Spiels sollen die Spieler zuerst in einem „Willkommen“-Fenster mit einem Mühlespielfeld im Hintergrund begrüßt werden. Die Spieler können in diesem Fenster ihre Namen eintragen und ihre Spielfarbe zuordnen. Ein Spieler bekommt die schwarzen Steine, der andere Spieler die weißen Steine. Die Zuordnung ermöglicht es, während dem Spielverlauf aktuelle Spielstände anzugeben. Schließlich kann das Spiel durch Klicken eines „Start“ Buttons gestartet werden.</p>
		<img src="images/Startbild.png">
		<p>Nun öffnet sich ein Fenster in der Mitte des Bildschirms, welches nicht weiter skalierbar sein soll. Auf diesem sitzen sich die beiden Spieler „gegenüber“. Im Fenster wird mittig das Mühlebrettspielfeld von oben blickend als Bild angezeigt. Links werden Angaben zum Spieler 1 gemacht, rechts zum Spieler 2. Ein Spiel kann jederzeit durch einen Button "Neues Spiel" abgebrochen und neu gestartet werden. Die Angaben beinhalten die Information über 
		<ul>
			<li>die Anzahl der Steine, die noch gesetzt werden können</li>
			<li>die Anzahl der Steine, die man insgesamt noch besitzt</li>
			<li>die Anzahl der Steine, die man dem anderen Spieler abgenommen hat</li>
		</ul>
		Über dem Spielfeld wird angezeigt, welcher Spieler sich gerade an der Reihe befindet. In diesem Feld werden zu gegebener Zeit auch Anweisungen oder Warnungen ausgegeben. Die Spieler bekommen so dauerhaft einen Überblick über den Spielverlauf und die aktuelle Situation. Die 24 Felder des Mühlespiels sind mit Buttons hinterlegt und in einem Array gespeichert. Sie können jeweils den Zustand „frei“, „weiß“ oder „schwarz annehmen“. Die gesamte Grafik der Benutzeroberfläche wird in 2D dargestellt. Nach jedem Spielzug wird das Spielfeld geprüft und die folgende Aktion darauf angepasst. </p>
		<p>In der Setzphase platzieren die Spieler abwechselnd ihre Steine auf dem Mühlespielfeld. 
		Durch Anklicken eines Feldes wird der Stein auf das Feld gesetzt, es nimmt somit den Zustand "weiß" oder "schwarz" an. Die Steine werden hierbei mit schwarzen bzw. weißen Kreisen angezeigt. Setzt ein Spieler einen Stein, kann dieser Spielzug nicht mehr rückgängig gemacht werden und automatisch ist der andere Spieler an der Reihe. Beim Anklicken eines besetzten Feldes wird im Infofeld eine Warnung ausgegeben, dass dieser Spielzug nicht erlaubt ist. Eine doppelte Besetzung eines Feldes ist nicht möglich. Sobald drei Steine einer Farbe in einer Reihe sind, wird angezeigt, dass nun ein Spielstein der anderen Farbe durch Anklicken vom Feld genommen werden kann. Dieser darf sich nicht in einer bestehenden Mühle befinden. Auch in diesem Fall wird ein entsprechender Hinweis im Infofeld angezeigt. </p>	
		<p>Sobald alle Steine gesetzt sind, kommt man in die zweite Phase des Spiels, der Zugphase. Zuerst klickt der Spieler auf den Stein, den er verschieben möchte und anschließend auf das Zielfeld. Sollte dieses besetzt sein oder sich nicht in direktem Anschluss zum ausgewählten Stein befinden, wird im Infofeld wieder eine entsprechende Warnung ausgegeben. Bei einer Mühle darf wieder ein Stein der anderen Farbe vom Spielfeld genommen werden.</p>
		<p>Zur letzten Phase des Spiels, der Springphase, gelangen die Spieler, sobald einer von ihnen nur noch drei Spielsteine auf dem Feld hat. Auch der Beginn dieser neuen Phase wird im Infofeld angezeigt. Spieler mit nur noch drei Steinen können nun zu einem beliebigen Feld springen. Die Einschränkung nur unmittelbar anliegende Felder anspielen zu können wird damit aufgehoben.</p>
		<img src="images/Hauptbild.png">
		
		<p>Sobald einem Spieler nur noch 2 Steine zur Verfügung stehen, öffnet sich ein neues „Sieger“- Fenster. In diesem wird der Gewinner mit seinem Namen angezeigt und beglückwünscht. 
		Ein zusätzliches Feature ist das Öffnen einer Gewinnstatistik. In dieser werden die Namen aller Spieler und die Anzahl ihrer gewonnenen Spiele tabellarisch aufgelistet. Voraussetzung hierfür ist die dauerhafte Speicherung der Namen mit den entsprechenden Spielausgängen. Durch einen Button "Zurück zum Start" kann ein neues Spiel begonnen werden. 
		Ein Spiel kann jederzeit durch das Anklicken durch das „Schließen“-Fenster beendet werden. Der Zwischenstand des Spiels wird hierbei nicht gespeichert. Generell können Spielzüge nicht rückgängig gemacht werden. Die bekannten Mühle-Spielregeln sollen im gesamten Spielverlauf eingehalten werden. Sie werden im Handbuch weiter beschrieben.
		</p>
		<img src="images/Endbild.png">
		<img src="images/Statistik.png">
	
		<h2>3. Architektur</h2>
		<p>Beschreibung der Software-Architektur</p>
		<p>	Die Klasse Spielbrett steht in einer Verbindung zur Klasse Spieler,
			welche mit den Methoden setzeStein() und nehmeStein() auf das Attribut Positionsarray zugreift.
			Auch die Klasse Stein greift mit der Methode move() auf dieses Attribut zu.
			Desweiteren steht die Klasse Stein in einer Komposition mit "Spieler". Da "Spieler" mit der Methode setzeStein()
			die Klasse "Stein" erst initialisiert kann "Stein" ohne "Spieler" nicht existieren.
			Jeder Spieler im normalen Spielverlauf 2 bis 9 Steine haben, aber in der Setzphase startet man mit 0 Steinen.
			Hingegen kann jeder Stein nur einem Spieler zugehörig sein. Für "Spielbrett" gilt, dass es 2 Spieler haben muss,
			und jeder Spieler nur ein Spielfeld haben kann.</p>
			Das Klassendiagramm kann mit Hilfe von Pseudo Code (siehe HTML Quelltext) erstellt werden <a href="https://mermaid-js.github.io/mermaid/#/classDiagram">(Hilfe)</a>.

		<div class="diagram">
			classDiagram
			class Spielbrett {
				-int [] Positionsarray
				-initialisieren()
				-neuesSpiel()
				+checkMuehle()
				-drawBoard()
			}
			class Spieler {
				-int 1oder2
				-string name
				-bool amZug
				-int numZuSetzen
				-int numVerbleibend
				-setzeStein()
				-nehmeStein()
			}
			class Stein {
				-string farbe
				-bool inMuehle
				-bool neueMuehle
				-int position
				-move()
			}
			class Frames {
				-int [] size
				-bool visibility
			}
			class WelcomeScreen {
				-JLabel LabelTop
				-JtextField Textfeld1
				-JtextField Textfeld2
				-JButton StartButton
			}
			class GameScreen {
				-JButton MenuButton
				-JButton NewGameButton
				-JButton ExitButton
				-JLabel LableTurn
				-JLabel LabelPl1
				-JLabel LabelPl2
				-JPanel PanelBoard
			}
			class EndOfGameScreen {
				-JLabel LabelMatch
				-JLabel LabelWinner
				-JPanel PanelFoto
				-JButton ButtonNext
			}
				
			
			Spielbrett "2" <-- "1" Spieler
			Spieler "1" *-- "0..9" Stein
			Stein --> Spielbrett
			Frames <|-- WelcomeScreen
			Frames <|-- GameScreen
			Frames <|-- EndOfGameScreen
			GameScreen --> Spielbrett
		
		</div>
		<h2>4. Aufwandsschätzung und Aufteilung</h2>
		<p>TODO: Schätzen Sie den Aufwand der verschiedenen Teile Ihres Programms ab und legen Sie fest, wie die Aufteilung auf die Gruppenmitglieder aussehen soll.</p>
		- Die meiste Zeit sollte für die Erfüllung der Grundanforderungen aufgebracht werden. D.h. im ersten Moment für die "Setzphase". Dies spiegelt sich auch in den Klassen wieder.
		  Gerade bei den Klassen "Spielbrett" und "Spieler" bedarf es hierzu wahrscheinlich den größten Zeitaufwand. Weniger Aufwand bedarf es wahrscheinlich bei der Klasse "Stein".
		  Zu beachten ist, dass genügend Zeit für Testphasen eingeplant werden.
		  Nach erster Einschätzung sollten die Grundanforderungen spätestens zu Woche 8 abgeschlossen sein. Zusätzliche Anforderungen können dann im Anschluss noch hinzugefügt werden.
		  Dies mit eingerechnet, plus eine finale Testphase und die Erstellung des Nutzerhandbuchs sollten zu Woche 11/12 abgeschlossen sein, sodass noch ein bis zwei Wochen "Puffer" vorhanden sind.
		  Die genaue Einteilung welche Gruppenmitglieder welche Aufgaben übernehmen folgt noch.
		<h2>Optional: Verweis auf andere HTML Dateien</h2>
		<p><a href="otherfile.html">Eine weitere HTML-Datei</a></p>
	</main>
	<footer></footer>
</body>
</html>

<!-- scripts to render diagrams (do not touch!) -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
	mermaid.initialize({startOnLoad:true});
	let diagrams = document.querySelectorAll(".diagram")
	mermaid.init({}, diagrams);
</script>
